<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cropy</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            min-height: 100vh;
            background: #222;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        #drop-area {
            border: 2px dashed #888;
            border-radius: 18px;
            width: 480px;
            height: 480px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #333;
            position: relative;
            transition: border-color 0.2s;
            margin-bottom: 20px;
        }
        #drop-area.dragover {
            border-color: #6cf;
        }
        #result-img {
            max-width: 96%;
            max-height: 96%;
            border-radius: 50%;
            box-shadow: 0 0 12px #000a;
            background: transparent;
        }
        #hint {
            color: #aaa;
            font-size: 18px;
            position: absolute;
            text-align: center;
            width: 100%;
            top: 44%;
            left: 0;
            user-select: none;
            pointer-events: none;
        }
        footer {
            width: 100vw;
            position: fixed;
            left: 0;
            bottom: 0;
            text-align: center;
            color: #777;
            font-size: 13px;
            background: #222;
            padding: 8px 0 6px 0;
            z-index: 10;
            letter-spacing: 0.5px;
            box-sizing: border-box;
        }
        #border-options {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 12px;
        }
        #border-options label {
            cursor: pointer;
        }
        #border-options input[type="number"] {
            background: #222;
            border: 1px solid #555;
            color: #eee;
            border-radius: 4px;
            padding: 2px 4px;
        }
    </style>
</head>
<body>
    <div id="drop-area">
        <span id="hint">Drop an image here<br>or paste (Ctrl+V)</span>
        <img id="result-img" style="display:none;" />
    </div>

    <!-- Border Options -->
    <div id="border-options">
        <label>
            <input type="checkbox" id="border-enable" checked>
            Enable border
        </label>
        &nbsp;&nbsp;
        <label>
            Color:
            <input type="color" id="border-color" value="#ffffff">
        </label>
        &nbsp;&nbsp;
        <label>
            Width:
            <input type="number" id="border-width" value="6" min="0" max="100" style="width:60px;"> px
        </label>
    </div>

    <footer>
        &copy; 2025 led-mirage &nbsp; Version 1.1.0
    </footer>
<script>
    const dropArea = document.getElementById('drop-area');
    const hint = document.getElementById('hint');
    const resultImg = document.getElementById('result-img');

    const borderEnable = document.getElementById('border-enable');
    const borderColor = document.getElementById('border-color');
    const borderWidth = document.getElementById('border-width');

    // Keep the last loaded original image
    let originalImage = null;

    // Load border settings from localStorage
    function loadBorderSettings() {
        const enable = localStorage.getItem('cropy:borderEnable');
        const color  = localStorage.getItem('cropy:borderColor');
        const width  = localStorage.getItem('cropy:borderWidth');

        if (enable !== null) borderEnable.checked = (enable === 'true');
        if (color  !== null) borderColor.value    = color;
        if (width  !== null) borderWidth.value    = width;
    }

    // Save border settings to localStorage
    function saveBorderSettings() {
        localStorage.setItem('cropy:borderEnable', borderEnable.checked ? 'true' : 'false');
        localStorage.setItem('cropy:borderColor',  borderColor.value);
        localStorage.setItem('cropy:borderWidth',  borderWidth.value);
    }

    // Handle an image file dropped or pasted
    function handleFile(file) {
        if (!file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            loadOriginalImage(e.target.result);
        };
        reader.readAsDataURL(file);
    }

    // Load original image and store it, then render with current options
    function loadOriginalImage(src) {
        const img = new window.Image();
        img.onload = function() {
            originalImage = img;        // keep globally
            renderImageWithBorder();    // render according to current options
        };
        img.src = src;
    }

     // Actual rendering: redraw from originalImage using current border options
    function renderImageWithBorder() {
        if (!originalImage) return;

        const img = originalImage;
        const w = img.width, h = img.height;
        const size = Math.min(w, h);
        const cx = w / 2, cy = h / 2;
        const r = size / 2;

        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Clear with full transparency
        ctx.clearRect(0, 0, size, size);

        // Clip to a circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(r, r, r, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.clip();

        // Draw the center region of the image
        ctx.drawImage(
            img,
            cx - r, cy - r, size, size, // source rect
            0, 0, size, size            // destination rect
        );
        ctx.restore();

        // Apply border (according to current options)
        if (borderEnable.checked) {
            const bw = parseFloat(borderWidth.value) || 0;
            if (bw > 0) {
                ctx.save();
                ctx.beginPath();
                const strokeRadius = r - bw / 2;
                ctx.arc(r, r, strokeRadius, 0, Math.PI * 2, true);
                ctx.strokeStyle = borderColor.value;
                ctx.lineWidth = bw;
                ctx.stroke();
                ctx.restore();
            }
        }

        // Show as PNG on the img element
        resultImg.src = canvas.toDataURL('image/png');
        resultImg.style.display = '';
        hint.style.display = 'none';
    }

    loadBorderSettings();

    // Drag & Drop
    dropArea.addEventListener('dragover', e => {
        e.preventDefault();
        dropArea.classList.add('dragover');
    });
    dropArea.addEventListener('dragleave', e => {
        dropArea.classList.remove('dragover');
    });
    dropArea.addEventListener('drop', e => {
        e.preventDefault();
        dropArea.classList.remove('dragover');
        if (e.dataTransfer.files.length) {
            handleFile(e.dataTransfer.files[0]);
        }
    });

    // Paste
    window.addEventListener('paste', e => {
        if (e.clipboardData && e.clipboardData.items.length) {
            for (let i = 0; i < e.clipboardData.items.length; i++) {
                const item = e.clipboardData.items[i];
                if (item.type.startsWith('image/')) {
                    handleFile(item.getAsFile());
                    break;
                }
            }
        }
    });

    // Re-render when options change
    const rerender = () => {
        saveBorderSettings();
        renderImageWithBorder();
    }

    borderEnable.addEventListener('change', rerender);
    borderColor.addEventListener('input', rerender);
    borderWidth.addEventListener('input', rerender);

    // Show hint initially
    resultImg.style.display = 'none';
    hint.style.display = '';
</script>
</body>
</html>
